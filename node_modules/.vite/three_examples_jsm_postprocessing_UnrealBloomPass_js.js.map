{
  "version": 3,
  "sources": ["../three/examples/jsm/shaders/LuminosityHighPassShader.js", "../three/examples/jsm/postprocessing/UnrealBloomPass.js"],
  "sourcesContent": ["import {\r\n\tColor\r\n} from 'three';\r\n\r\n/**\r\n * @module LuminosityHighPassShader\r\n * @three_import import { LuminosityHighPassShader } from 'three/addons/shaders/LuminosityHighPassShader.js';\r\n */\r\n\r\n/**\r\n * Luminosity high pass shader.\r\n *\r\n * @constant\r\n * @type {ShaderMaterial~Shader}\r\n */\r\nconst LuminosityHighPassShader = {\r\n\r\n\tname: 'LuminosityHighPassShader',\r\n\r\n\tuniforms: {\r\n\r\n\t\t'tDiffuse': { value: null },\r\n\t\t'luminosityThreshold': { value: 1.0 },\r\n\t\t'smoothWidth': { value: 1.0 },\r\n\t\t'defaultColor': { value: new Color( 0x000000 ) },\r\n\t\t'defaultOpacity': { value: 0.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tuniform vec3 defaultColor;\r\n\t\tuniform float defaultOpacity;\r\n\t\tuniform float luminosityThreshold;\r\n\t\tuniform float smoothWidth;\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\r\n\r\n\t\t\tfloat v = luminance( texel.xyz );\r\n\r\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\r\n\r\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\r\n\r\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\r\n\r\n\t\t}`\r\n\r\n};\r\n\r\nexport { LuminosityHighPassShader };\r\n", "import {\r\n\tAdditiveBlending,\r\n\tColor,\r\n\tHalfFloatType,\r\n\tMeshBasicMaterial,\r\n\tShaderMaterial,\r\n\tUniformsUtils,\r\n\tVector2,\r\n\tVector3,\r\n\tWebGLRenderTarget\r\n} from 'three';\r\nimport { Pass, FullScreenQuad } from './Pass.js';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\r\n\r\n/**\r\n * This pass is inspired by the bloom pass of Unreal Engine. It creates a\r\n * mip map chain of bloom textures and blurs them with different radii. Because\r\n * of the weighted combination of mips, and because larger blurs are done on\r\n * higher mips, this effect provides good quality and performance.\r\n *\r\n * When using this pass, tone mapping must be enabled in the renderer settings.\r\n *\r\n * Reference:\r\n * - [Bloom in Unreal Engine](https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/)\r\n *\r\n * ```js\r\n * const resolution = new THREE.Vector2( window.innerWidth, window.innerHeight );\r\n * const bloomPass = new UnrealBloomPass( resolution, 1.5, 0.4, 0.85 );\r\n * composer.addPass( bloomPass );\r\n * ```\r\n *\r\n * @augments Pass\r\n * @three_import import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\r\n */\r\nclass UnrealBloomPass extends Pass {\r\n\r\n\t/**\r\n\t * Constructs a new Unreal Bloom pass.\r\n\t *\r\n\t * @param {Vector2} [resolution] - The effect's resolution.\r\n\t * @param {number} [strength=1] - The Bloom strength.\r\n\t * @param {number} radius - The Bloom radius.\r\n\t * @param {number} threshold - The luminance threshold limits which bright areas contribute to the Bloom effect.\r\n\t */\r\n\tconstructor( resolution, strength = 1, radius, threshold ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\t/**\r\n\t\t * The Bloom strength.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 1\r\n\t\t */\r\n\t\tthis.strength = strength;\r\n\r\n\t\t/**\r\n\t\t * The Bloom radius. Must be in the range `[0,1]`.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t */\r\n\t\tthis.radius = radius;\r\n\r\n\t\t/**\r\n\t\t * The luminance threshold limits which bright areas contribute to the Bloom effect.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t */\r\n\t\tthis.threshold = threshold;\r\n\r\n\t\t/**\r\n\t\t * The effect's resolution.\r\n\t\t *\r\n\t\t * @type {Vector2}\r\n\t\t * @default (256,256)\r\n\t\t */\r\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\r\n\r\n\t\t/**\r\n\t\t * The effect's clear color\r\n\t\t *\r\n\t\t * @type {Color}\r\n\t\t * @default (0,0,0)\r\n\t\t */\r\n\t\tthis.clearColor = new Color( 0, 0, 0 );\r\n\r\n\t\t/**\r\n\t\t * Overwritten to disable the swap.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t */\r\n\t\tthis.needsSwap = false;\r\n\r\n\t\t// internals\r\n\r\n\t\t// render targets\r\n\t\tthis.renderTargetsHorizontal = [];\r\n\t\tthis.renderTargetsVertical = [];\r\n\t\tthis.nMips = 5;\r\n\t\tlet resx = Math.round( this.resolution.x / 2 );\r\n\t\tlet resy = Math.round( this.resolution.y / 2 );\r\n\r\n\t\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\r\n\t\tthis.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\r\n\t\tthis.renderTargetBright.texture.generateMipmaps = false;\r\n\r\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\r\n\r\n\t\t\tconst renderTargetHorizontal = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\r\n\r\n\t\t\trenderTargetHorizontal.texture.name = 'UnrealBloomPass.h' + i;\r\n\t\t\trenderTargetHorizontal.texture.generateMipmaps = false;\r\n\r\n\t\t\tthis.renderTargetsHorizontal.push( renderTargetHorizontal );\r\n\r\n\t\t\tconst renderTargetVertical = new WebGLRenderTarget( resx, resy, { type: HalfFloatType } );\r\n\r\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\r\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\r\n\r\n\t\t\tthis.renderTargetsVertical.push( renderTargetVertical );\r\n\r\n\t\t\tresx = Math.round( resx / 2 );\r\n\r\n\t\t\tresy = Math.round( resy / 2 );\r\n\r\n\t\t}\r\n\r\n\t\t// luminosity high pass material\r\n\r\n\t\tconst highPassShader = LuminosityHighPassShader;\r\n\t\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\r\n\r\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = threshold;\r\n\t\tthis.highPassUniforms[ 'smoothWidth' ].value = 0.01;\r\n\r\n\t\tthis.materialHighPassFilter = new ShaderMaterial( {\r\n\t\t\tuniforms: this.highPassUniforms,\r\n\t\t\tvertexShader: highPassShader.vertexShader,\r\n\t\t\tfragmentShader: highPassShader.fragmentShader\r\n\t\t} );\r\n\r\n\t\t// gaussian blur materials\r\n\r\n\t\tthis.separableBlurMaterials = [];\r\n\t\t// These sizes have been changed to account for the altered coefficients-calculation to avoid blockiness,\r\n\t\t// while retaining the same blur-strength. For details see https://github.com/mrdoob/three.js/pull/31528\r\n\t\tconst kernelSizeArray = [ 6, 10, 14, 18, 22 ];\r\n\t\tresx = Math.round( this.resolution.x / 2 );\r\n\t\tresy = Math.round( this.resolution.y / 2 );\r\n\r\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\r\n\r\n\t\t\tthis.separableBlurMaterials.push( this._getSeparableBlurMaterial( kernelSizeArray[ i ] ) );\r\n\r\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );\r\n\r\n\t\t\tresx = Math.round( resx / 2 );\r\n\r\n\t\t\tresy = Math.round( resy / 2 );\r\n\r\n\t\t}\r\n\r\n\t\t// composite material\r\n\r\n\t\tthis.compositeMaterial = this._getCompositeMaterial( this.nMips );\r\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;\r\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;\r\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;\r\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;\r\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;\r\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;\r\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;\r\n\r\n\t\tconst bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\r\n\t\tthis.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;\r\n\t\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\r\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\r\n\r\n\t\t// blend material\r\n\r\n\t\tthis.copyUniforms = UniformsUtils.clone( CopyShader.uniforms );\r\n\r\n\t\tthis.blendMaterial = new ShaderMaterial( {\r\n\t\t\tuniforms: this.copyUniforms,\r\n\t\t\tvertexShader: CopyShader.vertexShader,\r\n\t\t\tfragmentShader: CopyShader.fragmentShader,\r\n\t\t\tpremultipliedAlpha: true,\r\n\t\t\tblending: AdditiveBlending,\r\n\t\t\tdepthTest: false,\r\n\t\t\tdepthWrite: false,\r\n\t\t\ttransparent: true\r\n\t\t} );\r\n\r\n\t\tthis._oldClearColor = new Color();\r\n\t\tthis._oldClearAlpha = 1;\r\n\r\n\t\tthis._basic = new MeshBasicMaterial();\r\n\r\n\t\tthis._fsQuad = new FullScreenQuad( null );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Frees the GPU-related resources allocated by this instance. Call this\r\n\t * method whenever the pass is no longer used in your app.\r\n\t */\r\n\tdispose() {\r\n\r\n\t\tfor ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\r\n\r\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {\r\n\r\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderTargetBright.dispose();\r\n\r\n\t\t//\r\n\r\n\t\tfor ( let i = 0; i < this.separableBlurMaterials.length; i ++ ) {\r\n\r\n\t\t\tthis.separableBlurMaterials[ i ].dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis.compositeMaterial.dispose();\r\n\t\tthis.blendMaterial.dispose();\r\n\t\tthis._basic.dispose();\r\n\r\n\t\t//\r\n\r\n\t\tthis._fsQuad.dispose();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the size of the pass.\r\n\t *\r\n\t * @param {number} width - The width to set.\r\n\t * @param {number} height - The height to set.\r\n\t */\r\n\tsetSize( width, height ) {\r\n\r\n\t\tlet resx = Math.round( width / 2 );\r\n\t\tlet resy = Math.round( height / 2 );\r\n\r\n\t\tthis.renderTargetBright.setSize( resx, resy );\r\n\r\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\r\n\r\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\r\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\r\n\r\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'invSize' ].value = new Vector2( 1 / resx, 1 / resy );\r\n\r\n\t\t\tresx = Math.round( resx / 2 );\r\n\t\t\tresy = Math.round( resy / 2 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs the Bloom pass.\r\n\t *\r\n\t * @param {WebGLRenderer} renderer - The renderer.\r\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\r\n\t * destination for the pass.\r\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\r\n\t * previous pass from this buffer.\r\n\t * @param {number} deltaTime - The delta time in seconds.\r\n\t * @param {boolean} maskActive - Whether masking is active or not.\r\n\t */\r\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\r\n\r\n\t\trenderer.getClearColor( this._oldClearColor );\r\n\t\tthis._oldClearAlpha = renderer.getClearAlpha();\r\n\t\tconst oldAutoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\trenderer.setClearColor( this.clearColor, 0 );\r\n\r\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\r\n\r\n\t\t// Render input to screen\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\tthis._fsQuad.material = this._basic;\r\n\t\t\tthis._basic.map = readBuffer.texture;\r\n\r\n\t\t\trenderer.setRenderTarget( null );\r\n\t\t\trenderer.clear();\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t}\r\n\r\n\t\t// 1. Extract Bright Areas\r\n\r\n\t\tthis.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;\r\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;\r\n\t\tthis._fsQuad.material = this.materialHighPassFilter;\r\n\r\n\t\trenderer.setRenderTarget( this.renderTargetBright );\r\n\t\trenderer.clear();\r\n\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t// 2. Blur All the mips progressively\r\n\r\n\t\tlet inputRenderTarget = this.renderTargetBright;\r\n\r\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\r\n\r\n\t\t\tthis._fsQuad.material = this.separableBlurMaterials[ i ];\r\n\r\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;\r\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;\r\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\r\n\t\t\trenderer.clear();\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;\r\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;\r\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\r\n\t\t\trenderer.clear();\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\r\n\r\n\t\t}\r\n\r\n\t\t// Composite All the mips\r\n\r\n\t\tthis._fsQuad.material = this.compositeMaterial;\r\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;\r\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;\r\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\r\n\r\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\r\n\t\trenderer.clear();\r\n\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t// Blend it additively over the input texture\r\n\r\n\t\tthis._fsQuad.material = this.blendMaterial;\r\n\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;\r\n\r\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.setRenderTarget( null );\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.setRenderTarget( readBuffer );\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t}\r\n\r\n\t\t// Restore renderer settings\r\n\r\n\t\trenderer.setClearColor( this._oldClearColor, this._oldClearAlpha );\r\n\t\trenderer.autoClear = oldAutoClear;\r\n\r\n\t}\r\n\r\n\t// internals\r\n\r\n\t_getSeparableBlurMaterial( kernelRadius ) {\r\n\r\n\t\tconst coefficients = [];\r\n\t\tconst sigma = kernelRadius / 3;\r\n\r\n\t\tfor ( let i = 0; i < kernelRadius; i ++ ) {\r\n\r\n\t\t\tcoefficients.push( 0.39894 * Math.exp( - 0.5 * i * i / ( sigma * sigma ) ) / sigma );\r\n\r\n\t\t}\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\r\n\t\t\tdefines: {\r\n\t\t\t\t'KERNEL_RADIUS': kernelRadius\r\n\t\t\t},\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t'colorTexture': { value: null },\r\n\t\t\t\t'invSize': { value: new Vector2( 0.5, 0.5 ) }, // inverse texture size\r\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) },\r\n\t\t\t\t'gaussianCoefficients': { value: coefficients } // precomputed Gaussian coefficients\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\t\t#include <common>\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tuniform sampler2D colorTexture;\r\n\t\t\t\tuniform vec2 invSize;\r\n\t\t\t\tuniform vec2 direction;\r\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\r\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\r\n\r\n\t\t\t\t\tfor ( int i = 1; i < KERNEL_RADIUS; i ++ ) {\r\n\r\n\t\t\t\t\t\tfloat x = float( i );\r\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\r\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\r\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\r\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\r\n\t\t\t\t\t\tdiffuseSum += ( sample1 + sample2 ) * w;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgl_FragColor = vec4( diffuseSum, 1.0 );\r\n\r\n\t\t\t\t}`\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t_getCompositeMaterial( nMips ) {\r\n\r\n\t\treturn new ShaderMaterial( {\r\n\r\n\t\t\tdefines: {\r\n\t\t\t\t'NUM_MIPS': nMips\r\n\t\t\t},\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\t'blurTexture1': { value: null },\r\n\t\t\t\t'blurTexture2': { value: null },\r\n\t\t\t\t'blurTexture3': { value: null },\r\n\t\t\t\t'blurTexture4': { value: null },\r\n\t\t\t\t'blurTexture5': { value: null },\r\n\t\t\t\t'bloomStrength': { value: 1.0 },\r\n\t\t\t\t'bloomFactors': { value: null },\r\n\t\t\t\t'bloomTintColors': { value: null },\r\n\t\t\t\t'bloomRadius': { value: 0.0 }\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tuniform sampler2D blurTexture1;\r\n\t\t\t\tuniform sampler2D blurTexture2;\r\n\t\t\t\tuniform sampler2D blurTexture3;\r\n\t\t\t\tuniform sampler2D blurTexture4;\r\n\t\t\t\tuniform sampler2D blurTexture5;\r\n\t\t\t\tuniform float bloomStrength;\r\n\t\t\t\tuniform float bloomRadius;\r\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\r\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\r\n\r\n\t\t\t\tfloat lerpBloomFactor( const in float factor ) {\r\n\r\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\r\n\t\t\t\t\treturn mix( factor, mirrorFactor, bloomRadius );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\t// 3.0 for backwards compatibility with previous alpha-based intensity\r\n\t\t\t\t\tvec3 bloom = 3.0 * bloomStrength * (\r\n\t\t\t\t\t\tlerpBloomFactor( bloomFactors[ 0 ] ) * bloomTintColors[ 0 ] * texture2D( blurTexture1, vUv ).rgb +\r\n\t\t\t\t\t\tlerpBloomFactor( bloomFactors[ 1 ] ) * bloomTintColors[ 1 ] * texture2D( blurTexture2, vUv ).rgb +\r\n\t\t\t\t\t\tlerpBloomFactor( bloomFactors[ 2 ] ) * bloomTintColors[ 2 ] * texture2D( blurTexture3, vUv ).rgb +\r\n\t\t\t\t\t\tlerpBloomFactor( bloomFactors[ 3 ] ) * bloomTintColors[ 3 ] * texture2D( blurTexture4, vUv ).rgb +\r\n\t\t\t\t\t\tlerpBloomFactor( bloomFactors[ 4 ] ) * bloomTintColors[ 4 ] * texture2D( blurTexture5, vUv ).rgb\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tfloat bloomAlpha = max( bloom.r, max( bloom.g, bloom.b ) );\r\n\t\t\t\t\tgl_FragColor = vec4( bloom, bloomAlpha );\r\n\r\n\t\t\t\t}`\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\r\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\r\n\r\nexport { UnrealBloomPass };\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAeA,IAAM,2BAA2B;AAAA,EAEhC,MAAM;AAAA,EAEN,UAAU;AAAA,IAET,YAAY,EAAE,OAAO;AAAA,IACrB,uBAAuB,EAAE,OAAO;AAAA,IAChC,eAAe,EAAE,OAAO;AAAA,IACxB,gBAAgB,EAAE,OAAO,IAAI,MAAO;AAAA,IACpC,kBAAkB,EAAE,OAAO;AAAA;AAAA,EAI5B,cAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYxB,gBAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACN3B,oCAA8B,KAAK;AAAA,EAUlC,YAAa,YAAY,WAAW,GAAG,QAAQ,WAAY;AAE1D;AAQA,SAAK,WAAW;AAOhB,SAAK,SAAS;AAOd,SAAK,YAAY;AAQjB,SAAK,aAAe,eAAe,SAAc,IAAI,QAAS,WAAW,GAAG,WAAW,KAAM,IAAI,QAAS,KAAK;AAQ/G,SAAK,aAAa,IAAI,MAAO,GAAG,GAAG;AAQnC,SAAK,YAAY;AAKjB,SAAK,0BAA0B;AAC/B,SAAK,wBAAwB;AAC7B,SAAK,QAAQ;AACb,QAAI,OAAO,KAAK,MAAO,KAAK,WAAW,IAAI;AAC3C,QAAI,OAAO,KAAK,MAAO,KAAK,WAAW,IAAI;AAE3C,SAAK,qBAAqB,IAAI,kBAAmB,MAAM,MAAM,EAAE,MAAM;AACrE,SAAK,mBAAmB,QAAQ,OAAO;AACvC,SAAK,mBAAmB,QAAQ,kBAAkB;AAElD,aAAU,IAAI,GAAG,IAAI,KAAK,OAAO,KAAO;AAEvC,YAAM,yBAAyB,IAAI,kBAAmB,MAAM,MAAM,EAAE,MAAM;AAE1E,6BAAuB,QAAQ,OAAO,sBAAsB;AAC5D,6BAAuB,QAAQ,kBAAkB;AAEjD,WAAK,wBAAwB,KAAM;AAEnC,YAAM,uBAAuB,IAAI,kBAAmB,MAAM,MAAM,EAAE,MAAM;AAExE,2BAAqB,QAAQ,OAAO,sBAAsB;AAC1D,2BAAqB,QAAQ,kBAAkB;AAE/C,WAAK,sBAAsB,KAAM;AAEjC,aAAO,KAAK,MAAO,OAAO;AAE1B,aAAO,KAAK,MAAO,OAAO;AAAA;AAM3B,UAAM,iBAAiB;AACvB,SAAK,mBAAmB,cAAc,MAAO,eAAe;AAE5D,SAAK,iBAAkB,uBAAwB,QAAQ;AACvD,SAAK,iBAAkB,eAAgB,QAAQ;AAE/C,SAAK,yBAAyB,IAAI,eAAgB;AAAA,MACjD,UAAU,KAAK;AAAA,MACf,cAAc,eAAe;AAAA,MAC7B,gBAAgB,eAAe;AAAA;AAKhC,SAAK,yBAAyB;AAG9B,UAAM,kBAAkB,CAAE,GAAG,IAAI,IAAI,IAAI;AACzC,WAAO,KAAK,MAAO,KAAK,WAAW,IAAI;AACvC,WAAO,KAAK,MAAO,KAAK,WAAW,IAAI;AAEvC,aAAU,IAAI,GAAG,IAAI,KAAK,OAAO,KAAO;AAEvC,WAAK,uBAAuB,KAAM,KAAK,0BAA2B,gBAAiB;AAEnF,WAAK,uBAAwB,GAAI,SAAU,WAAY,QAAQ,IAAI,QAAS,IAAI,MAAM,IAAI;AAE1F,aAAO,KAAK,MAAO,OAAO;AAE1B,aAAO,KAAK,MAAO,OAAO;AAAA;AAM3B,SAAK,oBAAoB,KAAK,sBAAuB,KAAK;AAC1D,SAAK,kBAAkB,SAAU,gBAAiB,QAAQ,KAAK,sBAAuB,GAAI;AAC1F,SAAK,kBAAkB,SAAU,gBAAiB,QAAQ,KAAK,sBAAuB,GAAI;AAC1F,SAAK,kBAAkB,SAAU,gBAAiB,QAAQ,KAAK,sBAAuB,GAAI;AAC1F,SAAK,kBAAkB,SAAU,gBAAiB,QAAQ,KAAK,sBAAuB,GAAI;AAC1F,SAAK,kBAAkB,SAAU,gBAAiB,QAAQ,KAAK,sBAAuB,GAAI;AAC1F,SAAK,kBAAkB,SAAU,iBAAkB,QAAQ;AAC3D,SAAK,kBAAkB,SAAU,eAAgB,QAAQ;AAEzD,UAAM,eAAe,CAAE,GAAK,KAAK,KAAK,KAAK;AAC3C,SAAK,kBAAkB,SAAU,gBAAiB,QAAQ;AAC1D,SAAK,kBAAkB,CAAE,IAAI,QAAS,GAAG,GAAG,IAAK,IAAI,QAAS,GAAG,GAAG,IAAK,IAAI,QAAS,GAAG,GAAG,IAAK,IAAI,QAAS,GAAG,GAAG,IAAK,IAAI,QAAS,GAAG,GAAG;AAC5I,SAAK,kBAAkB,SAAU,mBAAoB,QAAQ,KAAK;AAIlE,SAAK,eAAe,cAAc,MAAO,WAAW;AAEpD,SAAK,gBAAgB,IAAI,eAAgB;AAAA,MACxC,UAAU,KAAK;AAAA,MACf,cAAc,WAAW;AAAA,MACzB,gBAAgB,WAAW;AAAA,MAC3B,oBAAoB;AAAA,MACpB,UAAU;AAAA,MACV,WAAW;AAAA,MACX,YAAY;AAAA,MACZ,aAAa;AAAA;AAGd,SAAK,iBAAiB,IAAI;AAC1B,SAAK,iBAAiB;AAEtB,SAAK,SAAS,IAAI;AAElB,SAAK,UAAU,IAAI,eAAgB;AAAA;AAAA,EAQpC,UAAU;AAET,aAAU,IAAI,GAAG,IAAI,KAAK,wBAAwB,QAAQ,KAAO;AAEhE,WAAK,wBAAyB,GAAI;AAAA;AAInC,aAAU,IAAI,GAAG,IAAI,KAAK,sBAAsB,QAAQ,KAAO;AAE9D,WAAK,sBAAuB,GAAI;AAAA;AAIjC,SAAK,mBAAmB;AAIxB,aAAU,IAAI,GAAG,IAAI,KAAK,uBAAuB,QAAQ,KAAO;AAE/D,WAAK,uBAAwB,GAAI;AAAA;AAIlC,SAAK,kBAAkB;AACvB,SAAK,cAAc;AACnB,SAAK,OAAO;AAIZ,SAAK,QAAQ;AAAA;AAAA,EAUd,QAAS,OAAO,QAAS;AAExB,QAAI,OAAO,KAAK,MAAO,QAAQ;AAC/B,QAAI,OAAO,KAAK,MAAO,SAAS;AAEhC,SAAK,mBAAmB,QAAS,MAAM;AAEvC,aAAU,IAAI,GAAG,IAAI,KAAK,OAAO,KAAO;AAEvC,WAAK,wBAAyB,GAAI,QAAS,MAAM;AACjD,WAAK,sBAAuB,GAAI,QAAS,MAAM;AAE/C,WAAK,uBAAwB,GAAI,SAAU,WAAY,QAAQ,IAAI,QAAS,IAAI,MAAM,IAAI;AAE1F,aAAO,KAAK,MAAO,OAAO;AAC1B,aAAO,KAAK,MAAO,OAAO;AAAA;AAAA;AAAA,EAiB5B,OAAQ,UAAU,aAAa,YAAY,WAAW,YAAa;AAElE,aAAS,cAAe,KAAK;AAC7B,SAAK,iBAAiB,SAAS;AAC/B,UAAM,eAAe,SAAS;AAC9B,aAAS,YAAY;AAErB,aAAS,cAAe,KAAK,YAAY;AAEzC,QAAK;AAAa,eAAS,MAAM,QAAQ,QAAQ,QAAS;AAI1D,QAAK,KAAK,gBAAiB;AAE1B,WAAK,QAAQ,WAAW,KAAK;AAC7B,WAAK,OAAO,MAAM,WAAW;AAE7B,eAAS,gBAAiB;AAC1B,eAAS;AACT,WAAK,QAAQ,OAAQ;AAAA;AAMtB,SAAK,iBAAkB,YAAa,QAAQ,WAAW;AACvD,SAAK,iBAAkB,uBAAwB,QAAQ,KAAK;AAC5D,SAAK,QAAQ,WAAW,KAAK;AAE7B,aAAS,gBAAiB,KAAK;AAC/B,aAAS;AACT,SAAK,QAAQ,OAAQ;AAIrB,QAAI,oBAAoB,KAAK;AAE7B,aAAU,IAAI,GAAG,IAAI,KAAK,OAAO,KAAO;AAEvC,WAAK,QAAQ,WAAW,KAAK,uBAAwB;AAErD,WAAK,uBAAwB,GAAI,SAAU,gBAAiB,QAAQ,kBAAkB;AACtF,WAAK,uBAAwB,GAAI,SAAU,aAAc,QAAQ,gBAAgB;AACjF,eAAS,gBAAiB,KAAK,wBAAyB;AACxD,eAAS;AACT,WAAK,QAAQ,OAAQ;AAErB,WAAK,uBAAwB,GAAI,SAAU,gBAAiB,QAAQ,KAAK,wBAAyB,GAAI;AACtG,WAAK,uBAAwB,GAAI,SAAU,aAAc,QAAQ,gBAAgB;AACjF,eAAS,gBAAiB,KAAK,sBAAuB;AACtD,eAAS;AACT,WAAK,QAAQ,OAAQ;AAErB,0BAAoB,KAAK,sBAAuB;AAAA;AAMjD,SAAK,QAAQ,WAAW,KAAK;AAC7B,SAAK,kBAAkB,SAAU,iBAAkB,QAAQ,KAAK;AAChE,SAAK,kBAAkB,SAAU,eAAgB,QAAQ,KAAK;AAC9D,SAAK,kBAAkB,SAAU,mBAAoB,QAAQ,KAAK;AAElE,aAAS,gBAAiB,KAAK,wBAAyB;AACxD,aAAS;AACT,SAAK,QAAQ,OAAQ;AAIrB,SAAK,QAAQ,WAAW,KAAK;AAC7B,SAAK,aAAc,YAAa,QAAQ,KAAK,wBAAyB,GAAI;AAE1E,QAAK;AAAa,eAAS,MAAM,QAAQ,QAAQ,QAAS;AAE1D,QAAK,KAAK,gBAAiB;AAE1B,eAAS,gBAAiB;AAC1B,WAAK,QAAQ,OAAQ;AAAA,WAEf;AAEN,eAAS,gBAAiB;AAC1B,WAAK,QAAQ,OAAQ;AAAA;AAMtB,aAAS,cAAe,KAAK,gBAAgB,KAAK;AAClD,aAAS,YAAY;AAAA;AAAA,EAMtB,0BAA2B,cAAe;AAEzC,UAAM,eAAe;AACrB,UAAM,QAAQ,eAAe;AAE7B,aAAU,IAAI,GAAG,IAAI,cAAc,KAAO;AAEzC,mBAAa,KAAM,UAAU,KAAK,IAAK,OAAQ,IAAI,IAAM,SAAQ,UAAY;AAAA;AAI9E,WAAO,IAAI,eAAgB;AAAA,MAE1B,SAAS;AAAA,QACR,iBAAiB;AAAA;AAAA,MAGlB,UAAU;AAAA,QACT,gBAAgB,EAAE,OAAO;AAAA,QACzB,WAAW,EAAE,OAAO,IAAI,QAAS,KAAK;AAAA,QACtC,aAAa,EAAE,OAAO,IAAI,QAAS,KAAK;AAAA,QACxC,wBAAwB,EAAE,OAAO;AAAA;AAAA,MAGlC,cAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAWxB,gBAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkC5B,sBAAuB,OAAQ;AAE9B,WAAO,IAAI,eAAgB;AAAA,MAE1B,SAAS;AAAA,QACR,YAAY;AAAA;AAAA,MAGb,UAAU;AAAA,QACT,gBAAgB,EAAE,OAAO;AAAA,QACzB,gBAAgB,EAAE,OAAO;AAAA,QACzB,gBAAgB,EAAE,OAAO;AAAA,QACzB,gBAAgB,EAAE,OAAO;AAAA,QACzB,gBAAgB,EAAE,OAAO;AAAA,QACzB,iBAAiB,EAAE,OAAO;AAAA,QAC1B,gBAAgB,EAAE,OAAO;AAAA,QACzB,mBAAmB,EAAE,OAAO;AAAA,QAC5B,eAAe,EAAE,OAAO;AAAA;AAAA,MAGzB,cAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAWxB,gBAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0C7B,gBAAgB,iBAAiB,IAAI,QAAS,GAAK;AACnD,gBAAgB,iBAAiB,IAAI,QAAS,GAAK;",
  "names": []
}
