{
  "version": 3,
  "sources": ["../three/examples/jsm/postprocessing/ShaderPass.js", "../three/examples/jsm/postprocessing/MaskPass.js", "../three/examples/jsm/postprocessing/EffectComposer.js"],
  "sourcesContent": ["import {\r\n\tShaderMaterial,\r\n\tUniformsUtils\r\n} from 'three';\r\nimport { Pass, FullScreenQuad } from './Pass.js';\r\n\r\n/**\r\n * This pass can be used to create a post processing effect\r\n * with a raw GLSL shader object. Useful for implementing custom\r\n * effects.\r\n *\r\n * ```js\r\n * const fxaaPass = new ShaderPass( FXAAShader );\r\n * composer.addPass( fxaaPass );\r\n * ```\r\n *\r\n * @augments Pass\r\n * @three_import import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';\r\n */\r\nclass ShaderPass extends Pass {\r\n\r\n\t/**\r\n\t * Constructs a new shader pass.\r\n\t *\r\n\t * @param {Object|ShaderMaterial} [shader] - A shader object holding vertex and fragment shader as well as\r\n\t * defines and uniforms. It's also valid to pass a custom shader material.\r\n\t * @param {string} [textureID='tDiffuse'] - The name of the texture uniform that should sample\r\n\t * the read buffer.\r\n\t */\r\n\tconstructor( shader, textureID = 'tDiffuse' ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\t/**\r\n\t\t * The name of the texture uniform that should sample the read buffer.\r\n\t\t *\r\n\t\t * @type {string}\r\n\t\t * @default 'tDiffuse'\r\n\t\t */\r\n\t\tthis.textureID = textureID;\r\n\r\n\t\t/**\r\n\t\t * The pass uniforms.\r\n\t\t *\r\n\t\t * @type {?Object}\r\n\t\t */\r\n\t\tthis.uniforms = null;\r\n\r\n\t\t/**\r\n\t\t * The pass material.\r\n\t\t *\r\n\t\t * @type {?ShaderMaterial}\r\n\t\t */\r\n\t\tthis.material = null;\r\n\r\n\t\tif ( shader instanceof ShaderMaterial ) {\r\n\r\n\t\t\tthis.uniforms = shader.uniforms;\r\n\r\n\t\t\tthis.material = shader;\r\n\r\n\t\t} else if ( shader ) {\r\n\r\n\t\t\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\t\tthis.material = new ShaderMaterial( {\r\n\r\n\t\t\t\tname: ( shader.name !== undefined ) ? shader.name : 'unspecified',\r\n\t\t\t\tdefines: Object.assign( {}, shader.defines ),\r\n\t\t\t\tuniforms: this.uniforms,\r\n\t\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\t\tfragmentShader: shader.fragmentShader\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\t// internals\r\n\r\n\t\tthis._fsQuad = new FullScreenQuad( this.material );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs the shader pass.\r\n\t *\r\n\t * @param {WebGLRenderer} renderer - The renderer.\r\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\r\n\t * destination for the pass.\r\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\r\n\t * previous pass from this buffer.\r\n\t * @param {number} deltaTime - The delta time in seconds.\r\n\t * @param {boolean} maskActive - Whether masking is active or not.\r\n\t */\r\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\r\n\r\n\t\tif ( this.uniforms[ this.textureID ] ) {\r\n\r\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\r\n\r\n\t\t}\r\n\r\n\t\tthis._fsQuad.material = this.material;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.setRenderTarget( null );\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.setRenderTarget( writeBuffer );\r\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\r\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Frees the GPU-related resources allocated by this instance. Call this\r\n\t * method whenever the pass is no longer used in your app.\r\n\t */\r\n\tdispose() {\r\n\r\n\t\tthis.material.dispose();\r\n\r\n\t\tthis._fsQuad.dispose();\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { ShaderPass };\r\n", "import { Pass } from './Pass.js';\r\n\r\n/**\r\n * This pass can be used to define a mask during post processing.\r\n * Meaning only areas of subsequent post processing are affected\r\n * which lie in the masking area of this pass. Internally, the masking\r\n * is implemented with the stencil buffer.\r\n *\r\n * ```js\r\n * const maskPass = new MaskPass( scene, camera );\r\n * composer.addPass( maskPass );\r\n * ```\r\n *\r\n * @augments Pass\r\n * @three_import import { MaskPass } from 'three/addons/postprocessing/MaskPass.js';\r\n */\r\nclass MaskPass extends Pass {\r\n\r\n\t/**\r\n\t * Constructs a new mask pass.\r\n\t *\r\n\t * @param {Scene} scene - The 3D objects in this scene will define the mask.\r\n\t * @param {Camera} camera - The camera.\r\n\t */\r\n\tconstructor( scene, camera ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\t/**\r\n\t\t * The scene that defines the mask.\r\n\t\t *\r\n\t\t * @type {Scene}\r\n\t\t */\r\n\t\tthis.scene = scene;\r\n\r\n\t\t/**\r\n\t\t * The camera.\r\n\t\t *\r\n\t\t * @type {Camera}\r\n\t\t */\r\n\t\tthis.camera = camera;\r\n\r\n\t\t/**\r\n\t\t * Overwritten to perform a clear operation by default.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default true\r\n\t\t */\r\n\t\tthis.clear = true;\r\n\r\n\t\t/**\r\n\t\t * Overwritten to disable the swap.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t */\r\n\t\tthis.needsSwap = false;\r\n\r\n\t\t/**\r\n\t\t * Whether to inverse the mask or not.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t */\r\n\t\tthis.inverse = false;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs a mask pass with the configured scene and camera.\r\n\t *\r\n\t * @param {WebGLRenderer} renderer - The renderer.\r\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\r\n\t * destination for the pass.\r\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\r\n\t * previous pass from this buffer.\r\n\t * @param {number} deltaTime - The delta time in seconds.\r\n\t * @param {boolean} maskActive - Whether masking is active or not.\r\n\t */\r\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\r\n\r\n\t\tconst context = renderer.getContext();\r\n\t\tconst state = renderer.state;\r\n\r\n\t\t// don't update color or depth\r\n\r\n\t\tstate.buffers.color.setMask( false );\r\n\t\tstate.buffers.depth.setMask( false );\r\n\r\n\t\t// lock buffers\r\n\r\n\t\tstate.buffers.color.setLocked( true );\r\n\t\tstate.buffers.depth.setLocked( true );\r\n\r\n\t\t// set up stencil\r\n\r\n\t\tlet writeValue, clearValue;\r\n\r\n\t\tif ( this.inverse ) {\r\n\r\n\t\t\twriteValue = 0;\r\n\t\t\tclearValue = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\twriteValue = 1;\r\n\t\t\tclearValue = 0;\r\n\r\n\t\t}\r\n\r\n\t\tstate.buffers.stencil.setTest( true );\r\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\r\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\r\n\t\tstate.buffers.stencil.setClear( clearValue );\r\n\t\tstate.buffers.stencil.setLocked( true );\r\n\r\n\t\t// draw into the stencil buffer\r\n\r\n\t\trenderer.setRenderTarget( readBuffer );\r\n\t\tif ( this.clear ) renderer.clear();\r\n\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\trenderer.setRenderTarget( writeBuffer );\r\n\t\tif ( this.clear ) renderer.clear();\r\n\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t// unlock color and depth buffer and make them writable for subsequent rendering/clearing\r\n\r\n\t\tstate.buffers.color.setLocked( false );\r\n\t\tstate.buffers.depth.setLocked( false );\r\n\r\n\t\tstate.buffers.color.setMask( true );\r\n\t\tstate.buffers.depth.setMask( true );\r\n\r\n\t\t// only render where stencil is set to 1\r\n\r\n\t\tstate.buffers.stencil.setLocked( false );\r\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1\r\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\r\n\t\tstate.buffers.stencil.setLocked( true );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * This pass can be used to clear a mask previously defined with {@link MaskPass}.\r\n *\r\n * ```js\r\n * const clearPass = new ClearMaskPass();\r\n * composer.addPass( clearPass );\r\n * ```\r\n *\r\n * @augments Pass\r\n */\r\nclass ClearMaskPass extends Pass {\r\n\r\n\t/**\r\n\t * Constructs a new clear mask pass.\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\r\n\t\t/**\r\n\t\t * Overwritten to disable the swap.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t */\r\n\t\tthis.needsSwap = false;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs the clear of the currently defined mask.\r\n\t *\r\n\t * @param {WebGLRenderer} renderer - The renderer.\r\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\r\n\t * destination for the pass.\r\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\r\n\t * previous pass from this buffer.\r\n\t * @param {number} deltaTime - The delta time in seconds.\r\n\t * @param {boolean} maskActive - Whether masking is active or not.\r\n\t */\r\n\trender( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\r\n\r\n\t\trenderer.state.buffers.stencil.setLocked( false );\r\n\t\trenderer.state.buffers.stencil.setTest( false );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { MaskPass, ClearMaskPass };\r\n", "import {\r\n\tClock,\r\n\tHalfFloatType,\r\n\tNoBlending,\r\n\tVector2,\r\n\tWebGLRenderTarget\r\n} from 'three';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\nimport { ShaderPass } from './ShaderPass.js';\r\nimport { ClearMaskPass, MaskPass } from './MaskPass.js';\r\n\r\n/**\r\n * Used to implement post-processing effects in three.js.\r\n * The class manages a chain of post-processing passes to produce the final visual result.\r\n * Post-processing passes are executed in order of their addition/insertion.\r\n * The last pass is automatically rendered to screen.\r\n *\r\n * This module can only be used with {@link WebGLRenderer}.\r\n *\r\n * ```js\r\n * const composer = new EffectComposer( renderer );\r\n *\r\n * // adding some passes\r\n * const renderPass = new RenderPass( scene, camera );\r\n * composer.addPass( renderPass );\r\n *\r\n * const glitchPass = new GlitchPass();\r\n * composer.addPass( glitchPass );\r\n *\r\n * const outputPass = new OutputPass()\r\n * composer.addPass( outputPass );\r\n *\r\n * function animate() {\r\n *\r\n * \tcomposer.render(); // instead of renderer.render()\r\n *\r\n * }\r\n * ```\r\n *\r\n * @three_import import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\r\n */\r\nclass EffectComposer {\r\n\r\n\t/**\r\n\t * Constructs a new effect composer.\r\n\t *\r\n\t * @param {WebGLRenderer} renderer - The renderer.\r\n\t * @param {WebGLRenderTarget} [renderTarget] - This render target and a clone will\r\n\t * be used as the internal read and write buffers. If not given, the composer creates\r\n\t * the buffers automatically.\r\n\t */\r\n\tconstructor( renderer, renderTarget ) {\r\n\r\n\t\t/**\r\n\t\t * The renderer.\r\n\t\t *\r\n\t\t * @type {WebGLRenderer}\r\n\t\t */\r\n\t\tthis.renderer = renderer;\r\n\r\n\t\tthis._pixelRatio = renderer.getPixelRatio();\r\n\r\n\t\tif ( renderTarget === undefined ) {\r\n\r\n\t\t\tconst size = renderer.getSize( new Vector2() );\r\n\t\t\tthis._width = size.width;\r\n\t\t\tthis._height = size.height;\r\n\r\n\t\t\trenderTarget = new WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType } );\r\n\t\t\trenderTarget.texture.name = 'EffectComposer.rt1';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._width = renderTarget.width;\r\n\t\t\tthis._height = renderTarget.height;\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderTarget1 = renderTarget;\r\n\t\tthis.renderTarget2 = renderTarget.clone();\r\n\t\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\r\n\r\n\t\t/**\r\n\t\t * A reference to the internal write buffer. Passes usually write\r\n\t\t * their result into this buffer.\r\n\t\t *\r\n\t\t * @type {WebGLRenderTarget}\r\n\t\t */\r\n\t\tthis.writeBuffer = this.renderTarget1;\r\n\r\n\t\t/**\r\n\t\t * A reference to the internal read buffer. Passes usually read\r\n\t\t * the previous render result from this buffer.\r\n\t\t *\r\n\t\t * @type {WebGLRenderTarget}\r\n\t\t */\r\n\t\tthis.readBuffer = this.renderTarget2;\r\n\r\n\t\t/**\r\n\t\t * Whether the final pass is rendered to the screen (default framebuffer) or not.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default true\r\n\t\t */\r\n\t\tthis.renderToScreen = true;\r\n\r\n\t\t/**\r\n\t\t * An array representing the (ordered) chain of post-processing passes.\r\n\t\t *\r\n\t\t * @type {Array<Pass>}\r\n\t\t */\r\n\t\tthis.passes = [];\r\n\r\n\t\t/**\r\n\t\t * A copy pass used for internal swap operations.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {ShaderPass}\r\n\t\t */\r\n\t\tthis.copyPass = new ShaderPass( CopyShader );\r\n\t\tthis.copyPass.material.blending = NoBlending;\r\n\r\n\t\t/**\r\n\t\t * The internal clock for managing time data.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {Clock}\r\n\t\t */\r\n\t\tthis.clock = new Clock();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Swaps the internal read/write buffers.\r\n\t */\r\n\tswapBuffers() {\r\n\r\n\t\tconst tmp = this.readBuffer;\r\n\t\tthis.readBuffer = this.writeBuffer;\r\n\t\tthis.writeBuffer = tmp;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds the given pass to the pass chain.\r\n\t *\r\n\t * @param {Pass} pass - The pass to add.\r\n\t */\r\n\taddPass( pass ) {\r\n\r\n\t\tthis.passes.push( pass );\r\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts the given pass at a given index.\r\n\t *\r\n\t * @param {Pass} pass - The pass to insert.\r\n\t * @param {number} index - The index into the pass chain.\r\n\t */\r\n\tinsertPass( pass, index ) {\r\n\r\n\t\tthis.passes.splice( index, 0, pass );\r\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the given pass from the pass chain.\r\n\t *\r\n\t * @param {Pass} pass - The pass to remove.\r\n\t */\r\n\tremovePass( pass ) {\r\n\r\n\t\tconst index = this.passes.indexOf( pass );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tthis.passes.splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the pass for the given index is the last enabled pass in the pass chain.\r\n\t *\r\n\t * @param {number} passIndex - The pass index.\r\n\t * @return {boolean} Whether the pass for the given index is the last pass in the pass chain.\r\n\t */\r\n\tisLastEnabledPass( passIndex ) {\r\n\r\n\t\tfor ( let i = passIndex + 1; i < this.passes.length; i ++ ) {\r\n\r\n\t\t\tif ( this.passes[ i ].enabled ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Executes all enabled post-processing passes in order to produce the final frame.\r\n\t *\r\n\t * @param {number} deltaTime - The delta time in seconds. If not given, the composer computes\r\n\t * its own time delta value.\r\n\t */\r\n\trender( deltaTime ) {\r\n\r\n\t\t// deltaTime value is in seconds\r\n\r\n\t\tif ( deltaTime === undefined ) {\r\n\r\n\t\t\tdeltaTime = this.clock.getDelta();\r\n\r\n\t\t}\r\n\r\n\t\tconst currentRenderTarget = this.renderer.getRenderTarget();\r\n\r\n\t\tlet maskActive = false;\r\n\r\n\t\tfor ( let i = 0, il = this.passes.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst pass = this.passes[ i ];\r\n\r\n\t\t\tif ( pass.enabled === false ) continue;\r\n\r\n\t\t\tpass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );\r\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );\r\n\r\n\t\t\tif ( pass.needsSwap ) {\r\n\r\n\t\t\t\tif ( maskActive ) {\r\n\r\n\t\t\t\t\tconst context = this.renderer.getContext();\r\n\t\t\t\t\tconst stencil = this.renderer.state.buffers.stencil;\r\n\r\n\t\t\t\t\t//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\r\n\t\t\t\t\tstencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );\r\n\r\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );\r\n\r\n\t\t\t\t\t//context.stencilFunc( context.EQUAL, 1, 0xffffffff );\r\n\t\t\t\t\tstencil.setFunc( context.EQUAL, 1, 0xffffffff );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.swapBuffers();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( MaskPass !== undefined ) {\r\n\r\n\t\t\t\tif ( pass instanceof MaskPass ) {\r\n\r\n\t\t\t\t\tmaskActive = true;\r\n\r\n\t\t\t\t} else if ( pass instanceof ClearMaskPass ) {\r\n\r\n\t\t\t\t\tmaskActive = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Resets the internal state of the EffectComposer.\r\n\t *\r\n\t * @param {WebGLRenderTarget} [renderTarget] - This render target has the same purpose like\r\n\t * the one from the constructor. If set, it is used to setup the read and write buffers.\r\n\t */\r\n\treset( renderTarget ) {\r\n\r\n\t\tif ( renderTarget === undefined ) {\r\n\r\n\t\t\tconst size = this.renderer.getSize( new Vector2() );\r\n\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\r\n\t\t\tthis._width = size.width;\r\n\t\t\tthis._height = size.height;\r\n\r\n\t\t\trenderTarget = this.renderTarget1.clone();\r\n\t\t\trenderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderTarget1.dispose();\r\n\t\tthis.renderTarget2.dispose();\r\n\t\tthis.renderTarget1 = renderTarget;\r\n\t\tthis.renderTarget2 = renderTarget.clone();\r\n\r\n\t\tthis.writeBuffer = this.renderTarget1;\r\n\t\tthis.readBuffer = this.renderTarget2;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Resizes the internal read and write buffers as well as all passes. Similar to {@link WebGLRenderer#setSize},\r\n\t * this method honors the current pixel ration.\r\n\t *\r\n\t * @param {number} width - The width in logical pixels.\r\n\t * @param {number} height - The height in logical pixels.\r\n\t */\r\n\tsetSize( width, height ) {\r\n\r\n\t\tthis._width = width;\r\n\t\tthis._height = height;\r\n\r\n\t\tconst effectiveWidth = this._width * this._pixelRatio;\r\n\t\tconst effectiveHeight = this._height * this._pixelRatio;\r\n\r\n\t\tthis.renderTarget1.setSize( effectiveWidth, effectiveHeight );\r\n\t\tthis.renderTarget2.setSize( effectiveWidth, effectiveHeight );\r\n\r\n\t\tfor ( let i = 0; i < this.passes.length; i ++ ) {\r\n\r\n\t\t\tthis.passes[ i ].setSize( effectiveWidth, effectiveHeight );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.\r\n\t * Setting the pixel ratio will automatically resize the composer.\r\n\t *\r\n\t * @param {number} pixelRatio - The pixel ratio to set.\r\n\t */\r\n\tsetPixelRatio( pixelRatio ) {\r\n\r\n\t\tthis._pixelRatio = pixelRatio;\r\n\r\n\t\tthis.setSize( this._width, this._height );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Frees the GPU-related resources allocated by this instance. Call this\r\n\t * method whenever the composer is no longer used in your app.\r\n\t */\r\n\tdispose() {\r\n\r\n\t\tthis.renderTarget1.dispose();\r\n\t\tthis.renderTarget2.dispose();\r\n\r\n\t\tthis.copyPass.dispose();\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { EffectComposer };\r\n"],
  "mappings": "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",
  "names": []
}
